<p-slide class="cover">
  <h1>Partiamo dall'inizioâ€¦Signal?</h1>
  <p-fragment class="center">
    <img alt="so-confused" src="img/so-confused.gif" />
  </p-fragment>
</p-slide>
<p-slide class="center">
  <p-note class="slide-quote text-sub-section" style="font-size: 0.6em; line-height: 4vw; margin-block-end: 1.3em"
    >â€œSignals are the primary means of managing state in your Solid application. They provide a way to store and update values, and are the foundation of reactivity in Solid.
    Signals can be used to represent any kind of state in your application, such as the current user, the current page, or the current theme. This can be any value, including
    primitive values such as strings and numbers, or complex values such as objects and arrays. â€
  </p-note>
  <p-note style="font-size: 0.5em"> https://docs.solidjs.com/concepts/signals </p-note>
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.7em">ğŸ™Œ Signal ğŸ™Œ</h4>
  <ul class="long-list">
    <p-fragment><li>ğŸ“Œ Un signal contiene sempre un valore</li></p-fragment>
    <p-fragment><li>ğŸ“Œ Al suo variare, chiunque lo utilizzi Ã¨ in grado di accedere al nuovo valore</li></p-fragment>
    <p-fragment><li>ğŸ“Œ La reattivitÃ  di signal Ã¨ sincrona ed il suo valore viene propagato istantaneamente</li></p-fragment>
    <p-fragment><li>ğŸ“Œ Ogni singolo signal Ã¨ chiamato â€œproducerâ€</li></p-fragment>
  </ul>
</p-slide>
<p-slide>
  <pre class="language-javascript" data-label-file="app.component.ts"><code class="small-line">
    import {signal} from '@angular/core';
    //...
    export class AppComponent {
      myFirstSignal = signal&lt;number>(1);

      constructor() {</code>
        <p-fragment><code>console.log('My first signal: ', this.myFirstSignal());
        // Output: My first signal: 1</code></p-fragment>
    <code>  }
  </code></pre>
</p-slide>
<p-slide class="cover-internal-sub-section">
  <div style="column-gap: 0.2em; justify-content: center" class="flex">
    â˜ï¸
    <h4>Un signal contiene sempre un valore</h4>
  </div>
</p-slide>
<p-slide style="position: relative">
  <pre class="language-javascript" data-label-file="app.component.ts"><code class="small-line">
    import {signal} from '@angular/core';
    //...
    export class AppComponent {
      myFirstSignal = signal&lt;number>();
    }
  </code></pre>
  <p-fragment
    style="--circle-sketch-height: 1.2em; position: absolute; inset-inline-start: 11.7em; z-index: 1; inset-block-start: 7.55em; width: 2em"
    class="circle-sketch-highlight"></p-fragment>
  <p-fragment>
    <img
      style="position: absolute; width: 12em; inset-block-end: 6.5em; inset-inline-start: 11em; z-index: 10"
      alt="error signal no initial value"
      src="img/error-signal-no-init-value.png" />
  </p-fragment>
</p-slide>
<p-slide class="center">
  <h4>ğŸ¤‘ <span class="text-sub-section">Consumer</span> ğŸ¤‘</h4>
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.7em">ğŸ™Œ Signal Consumer ğŸ™Œ</h4>
  <ul class="long-list">
    <p-fragment
      ><li>ğŸ“Œ Sia i template sia le funzioni che â€œleggonoâ€ i signal (es: <u>computed</u> ed <u>effect</u>) sono chiamati <b>â€œconsumerâ€</b></li></p-fragment
    >
    <p-fragment
      ><li>ğŸ“Œ E' possibile â€œiscriversiâ€ e reagire tramite i consumer, come ad esempio <b>effect</b></li></p-fragment
    >
    <p-fragment><li>ğŸ“Œ Quando questo accade, si crea una â€œconnessioneâ€ tra producer <-> consumer simile alla subscription negli observable</li></p-fragment>
    <p-fragment><li>ğŸ“Œ I producer inviano una notifica di aggiornamento e non direttamente il nuovo valore, che andrÃ  cosÃ¬ esplicitamente letto</li></p-fragment>
    <p-fragment><li>ğŸ“Œ Il consumer potrÃ  decidere di leggere il valore oppure non farlo mai.</li></p-fragment>
    <p-fragment><li>ğŸ“Œ I consumer sono memoized by default.</li></p-fragment>
  </ul>
</p-slide>
